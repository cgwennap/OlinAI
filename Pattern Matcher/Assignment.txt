Assignment.txt:

Pattern Matcher
posted Feb 4, 2013, 2:36 PM by Lynn Andrea Stein   [ updated Feb 6, 2013, 6:49 PM ]
Due:  Friday Feb 15 before class by email (one executable file OR a zipped folder OR a directory with your name on it in the designated turn-in folder on Public).  Turn in both executable code and a sample run (may be commented into you code file).

In this assignment you will write a simple chat-bot program in the style of Weizenbaum's Eliza.  You are not required to write this assignment in Scheme, but it is worth a higher percent (15% vs. 10%) if you do.  

If you would like step-by-step instructions on writing this assignment, you may find the appendix to this paper by Martincic useful (http://proc.isecon.org/2012/cases/2136.pdf).  Note that these instructions are for a Python pattern matcher (though you could just as easily implement in Lisp) and use a slightly different syntax from the one described below.  Either is acceptable.

Your pattern matcher should consist of the following pieces:
* A procedure that takes an input (I recommend a Scheme list of symbols, such as '(my name is lynn) ) and a pattern (such as '(my name is (= x)) ) and determines whether they match.  
The notation (= x) is intended to be a variable that matches any single word.  The variable notation may appear in the pattern but not in the input.
This procedure should return 
false if the two don't match, 
true if the two match and there are no variable matches created
a list of associations between variables and their matches --  in this case, x and lynn -- if the pattern matches the input while making these bindings.
You may choose any representation for the association list.
A procedure that takes an association list (i.e., a list of bindings such as the one created above) and an input (such as '(it is nice to meet you x) ) and replaces any of the associated variables with their associated matches.  So, for example, with bindings( ... (x lynn) ... ) the input '(it is nice to meet you x) would be transformed into '(it is nice to meet you lynn).
* A list of patterns/response pairs to generate a simple conversation.  For example:
'( ( (hello)                  (hi) )
  ( (how are you)       (thank you I am well) )
  ( (my name is (= x) )        (it is nice to meet you x) ) ; leave this out to start
  ( (i like (= x) and (= y) )    (do you prefer x or y) ) )    ; and this one too!

By combining these pieces, you should be able to build a simple chat program.  You will likely also want to use the (read) function in Scheme, which returns what the user types into a box.  The user's input should be inside parentheses but does not need a leading quote.  More info below (including a suggested development sequence and some advanced features/explanations of the pattern matching language).

You are welcome to be as creative as you want in generating dialogs.  The web is full of interesting chatbots to inspire you, including implementations of Eliza and the Loebner Prize competition transcripts.  Heck, if you build a good one you could even enter it into the 2013 competition!

Lots of fun related links at http://www.paulmckevitt.com/loebner2013/

Suggested development sequence:
Start by learning how to use (read) which is a scheme expression that returns a single expression (either a single symbol or a list).  For example, if you type hello in the box, (read) will return the symbol that would be generated by the scheme code 'hello.  If you type (my name is lynn) in the box, the (read) will return the list of symbols that would be generated by '(my name is lynn).  In other words, whatever you type into the box behaves as though you had quoted it.
Once you have (read) working the way you expect, try matching the input against a fixed pattern (or a few fixed patterns), like '(hello) and '(how are you).  You can build these into the matching procedure at first, but eventually you'll want to match against a list of patterns (or a list of lists of patterns and responses):  '( ( (hello) (hi) ) ( (how are you) (thank you I am well) ) )  Ideally, if the pattern matches, you should respond with the corresponding response.  You could also include multiple response options and choose randomly among them (using (random n) which is part of Racket or Pretty Big).
Next, build something that can also match a (single) variable in your .  Now you'll have to return a dictionary when the variable matches, not just true or false.  Extend this by being able to use the variable in the response:   '( ( (hello) (hi) ) ( (how are you) (thank you I am well) ) ( (my name is (= x)) (hello x) ) ) 
Advancing up the difficulty sequence:  Make the dictionary able to handle multiple different variables.  If two different variables appear in one pattern, each should match something.  So:
'((= x) likes (= y) s car) matches '(pat likes terry s car) [with bindings (x pat) (y terry)]
'((= x) likes (= y) s car) matches '(pat likes pat s car) [with bindings (x pat) (y pat)] 
Next step -- this one involves some interesting thinking about how to handle the dictionary -- is multiple uses of the same variable in a single pattern.  So:
'((= x) likes (= x) s car) matches '(pat likes pat s car) [with bindings (x pat)]
'((= x) likes (= x) s car) does NOT match '(pat likes terry s car) 
The following are entirely optional but can lead to some fun dialog ability:  
"not" variables (! x) which match anything except x
"comparator" variables (< x) which match values < x [where x might need to be a #]
a wild card -- often spelled ? -- that matches any single item but does not create a variable binding
multi-match variables (* x) which match 1 or more (or 0 or more, if you prefer) items, so 
'(I like (* x)) could match '(I like kittens) or '(I like AI students) [with bindings (x kittens) and (x (AI students)), respectively]